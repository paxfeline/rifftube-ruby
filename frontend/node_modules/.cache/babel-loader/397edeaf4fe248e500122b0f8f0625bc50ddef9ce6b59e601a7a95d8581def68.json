{"ast":null,"code":"var _jsxFileName = \"/Users/davidnewberry/Documents/test_rails/frontend/src/components/ViewInterface/ViewFilter.js\";\nimport React from 'react';\nimport YouTubeVideo from '../YouTubeVideo/YouTubeVideo';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nclass ViewFilter extends React.Component {\n  constructor(props) {\n    super(props);\n    // window.metaPlayhead gets updated by the youtube component\n    this.selectRiff = newRiff => {\n      // use id to find riff in \"master\" list\n      //const riff = this.props.riffs.find( r => r.id == selected_id );\n      let riff;\n      if (this.state.nonOverlappingRiffs.has(riff)) return;\n      const selectedRiffs = new Set(this.state.selectedRiffs);\n      const newFiltered = new Set(this.props.riffs);\n      const otherOverlaps = new Set(); //new Set( this.state.overlappingRiffs );\n      this.state.overlappingRiffs.forEach(el => otherOverlaps.add(new Set(el)));\n      riff = newRiff;\n      var curOverlap = new Set();\n      do {\n        // go through each set of overlapping riffs\n        for (const set of this.state.overlappingRiffs) {\n          // if that set contains the selected riff, remove all its values from the\n          if (set.has(riff)) {\n            set.forEach(el => {\n              selectedRiffs.delete(el);\n              newFiltered.delete(el);\n            });\n          }\n        }\n        selectedRiffs.add(riff);\n\n        // now the hard part\n\n        for (const r of selectedRiffs) {\n          // find and delete sets of overlap that contain a selected riff\n          const toDelete = [];\n          for (const set of otherOverlaps) {\n            if (set.has(r)) {\n              toDelete.push(set);\n            }\n          }\n          for (const set of toDelete) {\n            otherOverlaps.delete(set);\n            // from the sets in question, remove all their riffs from other overlap sets\n            // (because they are no longer valid options)\n            for (const redu of otherOverlaps) {\n              for (const tod of set) {\n                newFiltered.delete(tod);\n                redu.delete(tod);\n              }\n            }\n          }\n        }\n        for (const redu of otherOverlaps) {\n          if (redu.size > 0) curOverlap = new Set([...curOverlap, ...redu]);\n        }\n        if (curOverlap.size > 0) riff = curOverlap.values().next().value;\n      } while (curOverlap.size > 0);\n\n      // generate final filtered list\n      const filteredRiffs = [...newFiltered, ...selectedRiffs];\n      this.setState({\n        filteredRiffs,\n        selectedRiffs\n      });\n    };\n    window.metaPlayHead = /*#__PURE__*/React.createRef();\n    this.selectDiv = /*#__PURE__*/React.createRef();\n    window.metaUpdate = el => {\n      if (this.selectDiv.current)\n        // seems like it shouldn't be needed, but here we are\n        this.selectDiv.current.scrollLeft = el.offsetLeft - this.selectDiv.current.offsetWidth / 2;\n    };\n    this.state = {\n      filteredRiffs: [],\n      overlappingRiffs: [],\n      nonOverlappingRiffs: null,\n      selectedRiffs: null,\n      tracks: []\n    };\n    // filtered riffs is the final result\n    // overlapping riffs is a list of sets [of ids] of overlapping riffs\n    // selected riffs is a set\n    // tracks are used for the UI\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.riffs !== this.props.riffs) {\n      //debugger;\n\n      // if riffs have changed, we need to recalculate\n\n      // multiple tracks are used to display overlapping riffs at the same time\n      const tracks = [[]];\n      const trackPos = [0]; // time code where last riff on track ends\n\n      const nonOverlappingRiffs = new Set();\n\n      // used to keep track of conflicting riffs\n      const runningRiffs = [];\n\n      // these will overwrite the current values after being built\n      const overlappingRiffs = [];\n      const selectedRiffs = new Set();\n\n      // slope basically means \"was the last action to add or remove from the running list\"\n      var slope = 0;\n\n      // sort riffs by starting time\n      this.props.riffs.sort((e1, e2) => e1.time - e2.time);\n\n      // loop through sorted riffs\n      for (const riff of this.props.riffs) {\n        // check to see if any riffs end before this riff starts\n        if (runningRiffs.length > 0) {\n          // this could be optimized by first sorting running set\n          const toDelete = [];\n          for (const toCheck of runningRiffs) {\n            // (see above)\n            if (toCheck.time + toCheck.duration <= riff.time) {\n              // only add set if the prev action was an add,\n              // and there is more than 1 riff in the set\n              if (slope > 0 && runningRiffs.length > 1) {\n                overlappingRiffs.push(new Set(runningRiffs));\n\n                // when adding overlapping set, find if any are in track 0\n                // if so, they go into selectedRiffs\n                for (const candi of runningRiffs) {\n                  if (tracks[0].includes(candi)) {\n                    selectedRiffs.add(candi);\n                    break;\n                  }\n                }\n              } else if (slope > 0) {\n                // 'if' part may be unnecessary\n                nonOverlappingRiffs.add(toCheck);\n              }\n\n              // don't delete in place while looping\n              toDelete.push(toCheck);\n              slope = -1; // last action was to remove\n            }\n          }\n\n          for (const el of toDelete) runningRiffs.splice(runningRiffs.indexOf(el), 1);\n        }\n\n        // add this riff to running list\n        runningRiffs.push(riff);\n\n        // keep running list sorted by first ending\n        runningRiffs.sort((e1, e2) => e1.time + e1.duration - (e2.time + e2.duration));\n\n        // last action was to add\n        slope = 1;\n\n        // assign riff to a track\n        var flag = true;\n        for (var i = 0; i < tracks.length; i++) {\n          // check whether this track is available\n          if (trackPos[i] <= riff.time) {\n            tracks[i].push(riff);\n            trackPos[i] = riff.time + riff.duration;\n            flag = false;\n            break;\n          }\n        }\n\n        // if no track was found, add one\n        if (flag) {\n          tracks.push([riff]);\n          trackPos.push(riff.time + riff.duration);\n        }\n      }\n\n      // cleanup after loop\n      // check to see if running set has more than 1 riff\n      // if so, add it etc.\n      if (runningRiffs.length > 1) {\n        overlappingRiffs.push(new Set(runningRiffs));\n        for (const candi of runningRiffs) {\n          if (tracks[0].includes(candi)) {\n            selectedRiffs.add(candi);\n            break;\n          }\n        }\n      } else nonOverlappingRiffs.add(runningRiffs[0]);\n      const filteredRiffs = [...tracks[0]];\n      this.setState({\n        filteredRiffs,\n        overlappingRiffs,\n        nonOverlappingRiffs,\n        selectedRiffs,\n        tracks\n      });\n    }\n  }\n  render() {\n    return /*#__PURE__*/_jsxDEV(React.Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(YouTubeVideo, {\n        id: this.props.id,\n        riffs: this.state.filteredRiffs\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 216,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        ref: this.selectDiv,\n        style: {\n          fontSize: '2em',\n          overflow: 'hidden',\n          width: '640px'\n        },\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            height: `${this.state.tracks.length * 0.75}em`,\n            width: `${this.props.duration}em`,\n            position: 'relative'\n          },\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            id: \"meta-play-head\",\n            style: {\n              backgroundColor: 'red',\n              height: 'inherit'\n            },\n            ref: window.metaPlayHead\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 228,\n            columnNumber: 13\n          }, this), this.state.tracks.map((trackArray, ind) => /*#__PURE__*/_jsxDEV(\"div\", {\n            style: {\n              width: `${this.props.duration}em`,\n              height: '0.75em'\n            },\n            children: trackArray.map(riff => /*#__PURE__*/_jsxDEV(\"div\", {\n              style: {\n                position: 'absolute',\n                overflow: 'hidden',\n                textOverflow: 'ellipsis',\n                whiteSpace: 'nowrap',\n                fontSize: '0.25em',\n                lineHeight: '3em',\n                verticalAlign: 'middle',\n                left: `${riff.time * 4}em`,\n                height: '3em',\n                width: `${riff.duration * 4}em`,\n                backgroundColor: this.state.filteredRiffs.includes(riff) ? 'red' : 'lightgrey'\n              },\n              onClick: () => this.selectRiff(riff),\n              children: riff.name\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 239,\n              columnNumber: 19\n            }, this))\n          }, ind, false, {\n            fileName: _jsxFileName,\n            lineNumber: 234,\n            columnNumber: 15\n          }, this))]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 221,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 217,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 215,\n      columnNumber: 7\n    }, this);\n  }\n}\nexport default ViewFilter;","map":{"version":3,"names":["React","YouTubeVideo","ViewFilter","Component","constructor","props","selectRiff","newRiff","riff","state","nonOverlappingRiffs","has","selectedRiffs","Set","newFiltered","riffs","otherOverlaps","overlappingRiffs","forEach","el","add","curOverlap","set","delete","r","toDelete","push","redu","tod","size","values","next","value","filteredRiffs","setState","window","metaPlayHead","createRef","selectDiv","metaUpdate","current","scrollLeft","offsetLeft","offsetWidth","tracks","componentDidUpdate","prevProps","trackPos","runningRiffs","slope","sort","e1","e2","time","length","toCheck","duration","candi","includes","splice","indexOf","flag","i","render","id","fontSize","overflow","width","height","position","backgroundColor","map","trackArray","ind","textOverflow","whiteSpace","lineHeight","verticalAlign","left","name"],"sources":["/Users/davidnewberry/Documents/test_rails/frontend/src/components/ViewInterface/ViewFilter.js"],"sourcesContent":["import React from 'react';\nimport YouTubeVideo from '../YouTubeVideo/YouTubeVideo';\n\nclass ViewFilter extends React.Component {\n  constructor(props) {\n    super(props);\n    // window.metaPlayhead gets updated by the youtube component\n    window.metaPlayHead = React.createRef();\n    this.selectDiv = React.createRef();\n    window.metaUpdate = (el) => {\n      if (this.selectDiv.current)\n        // seems like it shouldn't be needed, but here we are\n        this.selectDiv.current.scrollLeft =\n          el.offsetLeft - this.selectDiv.current.offsetWidth / 2;\n    };\n\n    this.state = {\n      filteredRiffs: [],\n      overlappingRiffs: [],\n      nonOverlappingRiffs: null,\n      selectedRiffs: null,\n      tracks: [],\n    };\n    // filtered riffs is the final result\n    // overlapping riffs is a list of sets [of ids] of overlapping riffs\n    // selected riffs is a set\n    // tracks are used for the UI\n  }\n\n  selectRiff = (newRiff) => {\n    // use id to find riff in \"master\" list\n    //const riff = this.props.riffs.find( r => r.id == selected_id );\n    let riff;\n    if (this.state.nonOverlappingRiffs.has(riff)) return;\n\n    const selectedRiffs = new Set(this.state.selectedRiffs);\n\n    const newFiltered = new Set(this.props.riffs);\n\n    const otherOverlaps = new Set(); //new Set( this.state.overlappingRiffs );\n    this.state.overlappingRiffs.forEach((el) => otherOverlaps.add(new Set(el)));\n\n    riff = newRiff;\n\n    var curOverlap = new Set();\n    do {\n      // go through each set of overlapping riffs\n      for (const set of this.state.overlappingRiffs) {\n        // if that set contains the selected riff, remove all its values from the\n        if (set.has(riff)) {\n          set.forEach((el) => {\n            selectedRiffs.delete(el);\n            newFiltered.delete(el);\n          });\n        }\n      }\n\n      selectedRiffs.add(riff);\n\n      // now the hard part\n\n\n      for (const r of selectedRiffs) {\n        // find and delete sets of overlap that contain a selected riff\n        const toDelete = [];\n        for (const set of otherOverlaps) {\n          if (set.has(r)) {\n            toDelete.push(set);\n          }\n        }\n        for (const set of toDelete) {\n          otherOverlaps.delete(set);\n          // from the sets in question, remove all their riffs from other overlap sets\n          // (because they are no longer valid options)\n          for (const redu of otherOverlaps) {\n            for (const tod of set) {\n              newFiltered.delete(tod);\n              redu.delete(tod);\n            }\n          }\n        }\n      }\n      for (const redu of otherOverlaps) {\n        if (redu.size > 0) curOverlap = new Set([...curOverlap, ...redu]);\n      }\n\n      if (curOverlap.size > 0) riff = curOverlap.values().next().value;\n    } while (curOverlap.size > 0);\n\n    // generate final filtered list\n    const filteredRiffs = [...newFiltered, ...selectedRiffs];\n\n    this.setState({ filteredRiffs, selectedRiffs });\n  };\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.riffs !== this.props.riffs) {\n      //debugger;\n\n      // if riffs have changed, we need to recalculate\n\n      // multiple tracks are used to display overlapping riffs at the same time\n      const tracks = [[]];\n      const trackPos = [0]; // time code where last riff on track ends\n\n      const nonOverlappingRiffs = new Set();\n\n      // used to keep track of conflicting riffs\n      const runningRiffs = [];\n\n      // these will overwrite the current values after being built\n      const overlappingRiffs = [];\n      const selectedRiffs = new Set();\n\n      // slope basically means \"was the last action to add or remove from the running list\"\n      var slope = 0;\n\n      // sort riffs by starting time\n      this.props.riffs.sort((e1, e2) => e1.time - e2.time);\n\n      // loop through sorted riffs\n      for (const riff of this.props.riffs) {\n        // check to see if any riffs end before this riff starts\n        if (runningRiffs.length > 0) {\n          // this could be optimized by first sorting running set\n          const toDelete = [];\n          for (const toCheck of runningRiffs) {\n            // (see above)\n            if (toCheck.time + toCheck.duration <= riff.time) {\n              // only add set if the prev action was an add,\n              // and there is more than 1 riff in the set\n              if (slope > 0 && runningRiffs.length > 1) {\n                overlappingRiffs.push(new Set(runningRiffs));\n\n                // when adding overlapping set, find if any are in track 0\n                // if so, they go into selectedRiffs\n                for (const candi of runningRiffs) {\n                  if (tracks[0].includes(candi)) {\n                    selectedRiffs.add(candi);\n                    break;\n                  }\n                }\n              } else if (slope > 0) {\n                // 'if' part may be unnecessary\n                nonOverlappingRiffs.add(toCheck);\n              }\n\n              // don't delete in place while looping\n              toDelete.push(toCheck);\n              slope = -1; // last action was to remove\n            }\n          }\n          for (const el of toDelete)\n            runningRiffs.splice(runningRiffs.indexOf(el), 1);\n        }\n\n        // add this riff to running list\n        runningRiffs.push(riff);\n\n        // keep running list sorted by first ending\n        runningRiffs.sort(\n          (e1, e2) => e1.time + e1.duration - (e2.time + e2.duration)\n        );\n\n        // last action was to add\n        slope = 1;\n\n        // assign riff to a track\n        var flag = true;\n        for (var i = 0; i < tracks.length; i++) {\n          // check whether this track is available\n          if (trackPos[i] <= riff.time) {\n            tracks[i].push(riff);\n            trackPos[i] = riff.time + riff.duration;\n            flag = false;\n            break;\n          }\n        }\n\n        // if no track was found, add one\n        if (flag) {\n          tracks.push([riff]);\n          trackPos.push(riff.time + riff.duration);\n        }\n      }\n\n      // cleanup after loop\n      // check to see if running set has more than 1 riff\n      // if so, add it etc.\n      if (runningRiffs.length > 1) {\n        overlappingRiffs.push(new Set(runningRiffs));\n\n        for (const candi of runningRiffs) {\n          if (tracks[0].includes(candi)) {\n            selectedRiffs.add(candi);\n            break;\n          }\n        }\n      } else nonOverlappingRiffs.add(runningRiffs[0]);\n\n      const filteredRiffs = [...tracks[0]];\n\n      this.setState({\n        filteredRiffs,\n        overlappingRiffs,\n        nonOverlappingRiffs,\n        selectedRiffs,\n        tracks,\n      });\n    }\n  }\n\n  render() {\n    return (\n      <React.Fragment>\n        <YouTubeVideo id={this.props.id} riffs={this.state.filteredRiffs} />\n        <div\n          ref={this.selectDiv}\n          style={{ fontSize: '2em', overflow: 'hidden', width: '640px' }}\n        >\n          <div\n            style={{\n              height: `${this.state.tracks.length * 0.75}em`,\n              width: `${this.props.duration}em`,\n              position: 'relative',\n            }}\n          >\n            <div\n              id=\"meta-play-head\"\n              style={{ backgroundColor: 'red', height: 'inherit' }}\n              ref={window.metaPlayHead}\n            />\n            {this.state.tracks.map((trackArray, ind) => (\n              <div\n                style={{ width: `${this.props.duration}em`, height: '0.75em' }}\n                key={ind}\n              >\n                {trackArray.map((riff) => (\n                  <div\n                    style={{\n                      position: 'absolute',\n                      overflow: 'hidden',\n                      textOverflow: 'ellipsis',\n                      whiteSpace: 'nowrap',\n                      fontSize: '0.25em',\n                      lineHeight: '3em',\n                      verticalAlign: 'middle',\n                      left: `${riff.time * 4}em`,\n                      height: '3em',\n                      width: `${riff.duration * 4}em`,\n                      backgroundColor: this.state.filteredRiffs.includes(riff)\n                        ? 'red'\n                        : 'lightgrey',\n                    }}\n                    onClick={() => this.selectRiff(riff)}\n                  >\n                    {riff.name}\n                  </div>\n                ))}\n              </div>\n            ))}\n          </div>\n        </div>\n      </React.Fragment>\n    );\n  }\n}\n\nexport default ViewFilter;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}