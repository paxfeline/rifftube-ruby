{"ast":null,"code":"import { DELETE_RIFF, SAVE_NEW_RIFF, SAVE_EDIT_RIFF, RECEIVE_RIFF_LIST, SAVE_NEW_RIFF_SUCCESS, SAVE_EDIT_RIFF_SUCCESS, UPDATE_RIFF_TIME_SUCCESS } from '../actions/index.js';\nlet initialState = [];\nconst riffsReducer = function () {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  switch (action.type) {\n    case DELETE_RIFF:\n      {\n        let ret = {\n          ...state\n        };\n        delete ret[action.id];\n        return ret;\n      }\n    case RECEIVE_RIFF_LIST:\n      return action.payload.reduce((acc, cur) => {\n        cur.payload = cur.isText ? cur.text : null;\n        cur.type = cur.isText ? 'text' : 'audio';\n        acc[cur.id] = cur;\n        return acc;\n      }, {});\n    case UPDATE_RIFF_TIME_SUCCESS:\n      {\n        let ret = {\n          ...state\n        };\n        ret[action.id].start = Number(action.start);\n        return ret;\n      }\n    case SAVE_NEW_RIFF:\n      // code block for variable grouping\n      {\n        // create object from modified entries\n        const riff = Object.fromEntries([...Object.entries(action.payload)\n        // convert keys from riff[*] to *\n        // i.e. riff[duration] to duration\n        .map(el => {\n          var _el$0$match;\n          return [(_el$0$match = el[0].match(/riff\\[(\\w+)\\]/)) === null || _el$0$match === void 0 ? void 0 : _el$0$match[1], el[1]];\n        }), [\"unsaved\", true]]);\n\n        //...action.payload,\n        delete riff.payload;\n\n        // create new riffs list, including new riff\n        return {\n          ...state,\n          [`temp-${riff.tempId}`]: riff\n        };\n      }\n    case SAVE_EDIT_RIFF:\n      {\n        const riff = {\n          ...action.payload,\n          saved: false\n        };\n        delete riff.payload;\n        let riffs = [...state];\n        riffs[riff.id] = riff;\n        return riffs;\n      }\n    case SAVE_NEW_RIFF_SUCCESS:\n      {\n        let riffs = {\n          ...state\n        };\n        riffs.forEach((el, ind, arr) => {\n          if (el.tempId === action.payload.tempId) arr[ind] = {\n            ...el,\n            id: action.payload.id\n          };\n          //el.id = action.payload.id;\n        });\n\n        return riffs;\n      }\n    case SAVE_EDIT_RIFF_SUCCESS:\n      {}\n    default:\n      return state;\n  }\n};\nexport default riffsReducer;","map":{"version":3,"names":["DELETE_RIFF","SAVE_NEW_RIFF","SAVE_EDIT_RIFF","RECEIVE_RIFF_LIST","SAVE_NEW_RIFF_SUCCESS","SAVE_EDIT_RIFF_SUCCESS","UPDATE_RIFF_TIME_SUCCESS","initialState","riffsReducer","state","action","type","ret","id","payload","reduce","acc","cur","isText","text","start","Number","riff","Object","fromEntries","entries","map","el","match","tempId","saved","riffs","forEach","ind","arr"],"sources":["/Users/davidnewberry/Documents/test_rails/frontend/src/reducers/riffs-reducer.js"],"sourcesContent":["import {\n  DELETE_RIFF,\n  SAVE_NEW_RIFF,\n  SAVE_EDIT_RIFF,\n  RECEIVE_RIFF_LIST,\n  SAVE_NEW_RIFF_SUCCESS,\n  SAVE_EDIT_RIFF_SUCCESS,\n  UPDATE_RIFF_TIME_SUCCESS,\n} from '../actions/index.js';\n\nlet initialState = [];\n\nconst riffsReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case DELETE_RIFF:\n    {\n      let ret = { ...state };\n      delete ret[action.id]\n      return ret;\n    }\n    case RECEIVE_RIFF_LIST:\n      return action.payload.reduce(\n        (acc, cur) =>\n        {\n          cur.payload = cur.isText ? cur.text : null;\n          cur.type = cur.isText ? 'text' : 'audio';\n          acc[cur.id] = cur;\n          return acc;\n        },\n        {}\n      );\n    case UPDATE_RIFF_TIME_SUCCESS:\n    {\n      let ret = { ...state };\n      ret[action.id].start = Number(action.start);\n      return ret;\n    }\n    case SAVE_NEW_RIFF: // code block for variable grouping\n    {\n      // create object from modified entries\n      const riff = Object.fromEntries(\n        [\n          ...(Object.entries(action.payload)\n            // convert keys from riff[*] to *\n            // i.e. riff[duration] to duration\n            .map(\n              el =>\n              (\n                [\n                  el[0].match(/riff\\[(\\w+)\\]/)?.[1],\n                  el[1]\n                ]\n              )\n            )),\n          [\"unsaved\", true]\n        ]\n      );\n\n        //...action.payload,\n      delete riff.payload;\n\n      // create new riffs list, including new riff\n      return (\n      {\n        ...state,\n        [`temp-${riff.tempId}`]: riff\n      });\n    }\n    case SAVE_EDIT_RIFF:\n    {\n      const riff = { ...action.payload, saved: false };\n      delete riff.payload;\n\n      let riffs = [...state];\n      riffs[riff.id] = riff;\n\n      return riffs;\n    }\n\n    case SAVE_NEW_RIFF_SUCCESS:\n    {\n      let riffs = {...state};\n      riffs.forEach((el, ind, arr) => {\n        if (el.tempId === action.payload.tempId)\n          arr[ind] = { ...el, id: action.payload.id };\n        //el.id = action.payload.id;\n      });\n      return riffs;\n    }\n    case SAVE_EDIT_RIFF_SUCCESS:\n    {\n      \n    }\n\n    default:\n      return state;\n  }\n};\n\nexport default riffsReducer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}