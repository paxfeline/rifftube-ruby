{"ast":null,"code":"import { SET_VIDEO_ID, DELETE_RIFF, SAVE_NEW_RIFF, CREATE_TEMP_AUDIO_RIFF, CREATE_TEMP_TEXT_RIFF, SAVE_TEMP_AUDIO, CANCEL_EDIT, EDIT_RIFF, RECEIVE_RIFF_LIST, SAVE_NEW_RIFF_SUCCESS, UPDATE_RIFF_TIME_SUCCESS } from '../actions/index.js';\nlet initialState = {\n  all: [],\n  temp: null,\n  editIndex: null\n};\nconst riffsReducer = function () {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  switch (action.type) {\n    case CREATE_TEMP_AUDIO_RIFF:\n    case CREATE_TEMP_TEXT_RIFF:\n      return {\n        ...state,\n        temp: {\n          ...state.temp,\n          type: action.type === CREATE_TEMP_AUDIO_RIFF ? 'audio' : 'text',\n          // @ts-ignore\n          // rifftubePlayer isn't normally on the window object so this throws an error but it works.\n          time: window.rifftubePlayer.getCurrentTime(),\n          video_id: action.videoID,\n          tempId: new Date().getUTCMilliseconds() // used to get perm id from server\n        },\n\n        editIndex: null\n      };\n    case EDIT_RIFF:\n      return {\n        ...state,\n        temp: {\n          ...state.all[action.payload]\n        },\n        // copy specified riff to tempRiff\n        editIndex: action.payload\n      };\n    case DELETE_RIFF:\n      {\n        let ret = {\n          ...state\n        };\n        ret.all = ret.all.filter(el => el.id !== action.id);\n\n        // silly change\n\n        /*let index = ret.all.findIndex(el => el.id === action.id);\n           ret.all.splice(index, 1);*/\n\n        return ret;\n      }\n    case SAVE_TEMP_AUDIO:\n      return {\n        ...state,\n        temp: {\n          ...state.temp,\n          duration: action.duration\n          //payload: action.payload\n        }\n      };\n\n    case CANCEL_EDIT:\n      return {\n        ...state,\n        temp: null,\n        editIndex: null\n      };\n    case RECEIVE_RIFF_LIST:\n      //debugger;\n      return {\n        ...state,\n        timestamp: Date.now(),\n        all: action.payload.map(el => ({\n          ...el,\n          time: el.start,\n          payload: el.isText ? el.text : null,\n          type: el.isText ? 'text' : 'audio'\n        }))\n      };\n    case UPDATE_RIFF_TIME_SUCCESS:\n      let riffs = [...state.all];\n      riffs.forEach((el, ind, arr) => {\n        if (el.id === action.id) arr[ind] = {\n          ...el,\n          id: action.id,\n          time: Number(action.time)\n        };\n        //el.id = action.payload.id;\n      });\n\n      let ret = {\n        ...state,\n        all: riffs\n      };\n      return ret;\n    case SAVE_NEW_RIFF:\n      // code block for variable grouping\n      {\n        debugger;\n        const actionPayload = action.payload;\n        if (state.temp.type === \"audio\") delete riff.payload;\n        const riff = {\n          ...state.temp,\n          ...actionPayload,\n          saved: false\n        };\n\n        // create new riffs.all list, including new riff\n        let riffs = [...state.all, riff];\n        return {\n          all: riffs,\n          temp: null,\n          editIndex: null\n        };\n      }\n    case SAVE_EDIT_RIFF:\n      {\n        const {\n          payload,\n          ...actionPayload\n        } = action.payload; // payload (audio data) will be ignored\n        const riff = {\n          ...state.temp,\n          ...actionPayload,\n          saved: false\n        };\n\n        // the payload should be included if this is a text riff\n        if (state.temp.type === \"text\") riff.payload = payload;\n        let riffs;\n        riffs = [...state.all];\n        riffs[state.editIndex] = riff;\n        return {\n          all: riffs,\n          temp: null,\n          editIndex: null\n        };\n      }\n    case SAVE_NEW_RIFF_SUCCESS:\n      if (action.payload.type === 'add') {\n        let riffs = [...state.all];\n        riffs.forEach((el, ind, arr) => {\n          if (el.tempId === action.payload.tempId) arr[ind] = {\n            ...el,\n            id: action.payload.id\n          };\n          //el.id = action.payload.id;\n        });\n\n        let ret = {\n          ...state,\n          all: riffs\n        };\n        return ret;\n      } else {}\n    //return state;\n\n    /*\n    case LOAD_RIFF:\n      let ret = { ...state }; // will this work?\n      ret.all[action.payload].loading = true;\n      return ret;\n    case RIFF_LOADED: {\n      debugger;\n      const b = new Blob(new Array(action.payload), { type: 'audio/mp3' });\n      let riffs = [...state.all];\n      riffs.forEach(el => {\n        if (el.id === action.id) {\n          el.payload = b;\n          el.loading = false;\n        }\n      });\n      let ret = { ...state, all: riffs };\n       // if this is being edited currently, tempRiff needs to be updated as well\n      // editIndex != null simply means that something is being edited\n      if (state.editIndex !== null && state.temp.id === action.id)\n        ret.temp = { ...ret.temp, payload: b };\n       return ret;\n    }\n    */\n\n    default:\n      return state;\n  }\n};\nexport default riffsReducer;","map":{"version":3,"names":["SET_VIDEO_ID","DELETE_RIFF","SAVE_NEW_RIFF","CREATE_TEMP_AUDIO_RIFF","CREATE_TEMP_TEXT_RIFF","SAVE_TEMP_AUDIO","CANCEL_EDIT","EDIT_RIFF","RECEIVE_RIFF_LIST","SAVE_NEW_RIFF_SUCCESS","UPDATE_RIFF_TIME_SUCCESS","initialState","all","temp","editIndex","riffsReducer","state","action","type","time","window","rifftubePlayer","getCurrentTime","video_id","videoID","tempId","Date","getUTCMilliseconds","payload","ret","filter","el","id","duration","timestamp","now","map","start","isText","text","riffs","forEach","ind","arr","Number","actionPayload","riff","saved","SAVE_EDIT_RIFF"],"sources":["/Users/davidnewberry/Documents/test_rails/frontend/src/reducers/riffs-reducer.js"],"sourcesContent":["import {\n  SET_VIDEO_ID,\n  DELETE_RIFF,\n  SAVE_NEW_RIFF,\n  CREATE_TEMP_AUDIO_RIFF,\n  CREATE_TEMP_TEXT_RIFF,\n  SAVE_TEMP_AUDIO,\n  CANCEL_EDIT,\n  EDIT_RIFF,\n  RECEIVE_RIFF_LIST,\n  SAVE_NEW_RIFF_SUCCESS,\n  UPDATE_RIFF_TIME_SUCCESS,\n} from '../actions/index.js';\n\nlet initialState = {\n  all: [],\n  temp: null,\n  editIndex: null,\n};\n\nconst riffsReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case CREATE_TEMP_AUDIO_RIFF:\n    case CREATE_TEMP_TEXT_RIFF:\n      return {\n        ...state,\n        temp: {\n          ...state.temp,\n          type: action.type === CREATE_TEMP_AUDIO_RIFF ? 'audio' : 'text',\n          // @ts-ignore\n          // rifftubePlayer isn't normally on the window object so this throws an error but it works.\n          time: window.rifftubePlayer.getCurrentTime(),\n          video_id: action.videoID,\n          tempId: new Date().getUTCMilliseconds(), // used to get perm id from server\n        },\n        editIndex: null,\n      };\n    case EDIT_RIFF:\n      return {\n        ...state,\n        temp: { ...state.all[action.payload] }, // copy specified riff to tempRiff\n        editIndex: action.payload,\n      };\n    case DELETE_RIFF: {\n      let ret = { ...state };\n\n      ret.all = ret.all.filter((el) => el.id !== action.id);\n\n      // silly change\n\n      /*let index = ret.all.findIndex(el => el.id === action.id);\n\n\n\n      ret.all.splice(index, 1);*/\n\n      return ret;\n    }\n    case SAVE_TEMP_AUDIO:\n      return {\n        ...state,\n        temp: {\n          ...state.temp,\n          duration: action.duration,\n          //payload: action.payload\n        },\n      };\n    case CANCEL_EDIT:\n      return {\n        ...state,\n        temp: null,\n        editIndex: null,\n      };\n    case RECEIVE_RIFF_LIST:\n      //debugger;\n      return {\n        ...state,\n        timestamp: Date.now(),\n        all: action.payload.map((el) => ({\n          ...el,\n          time: el.start,\n          payload: el.isText ? el.text : null,\n          type: el.isText ? 'text' : 'audio',\n        })),\n      };\n\n    case UPDATE_RIFF_TIME_SUCCESS:\n      let riffs = [...state.all];\n      riffs.forEach((el, ind, arr) => {\n        if (el.id === action.id)\n          arr[ind] = { ...el, id: action.id, time: Number(action.time) };\n        //el.id = action.payload.id;\n      });\n      let ret = { ...state, all: riffs };\n      return ret;\n\n      case SAVE_NEW_RIFF: // code block for variable grouping\n      {\n        debugger;\n        const actionPayload = action.payload;\n        if ( state.temp.type === \"audio\" )\n          delete riff.payload;\n        const riff = { ...state.temp, ...actionPayload, saved: false };\n  \n        // create new riffs.all list, including new riff\n        let riffs = [...state.all, riff];\n  \n        return {\n          all: riffs,\n          temp: null,\n          editIndex: null,\n        };\n      }\n\n    case SAVE_EDIT_RIFF:\n    {\n      const { payload, ...actionPayload } = action.payload; // payload (audio data) will be ignored\n      const riff = { ...state.temp, ...actionPayload, saved: false };\n\n      // the payload should be included if this is a text riff\n      if ( state.temp.type === \"text\" )\n        riff.payload = payload;\n\n      let riffs;\n      \n      riffs = [...state.all];\n      riffs[state.editIndex] = riff;\n\n      return {\n        all: riffs,\n        temp: null,\n        editIndex: null,\n      };\n    }\n\n    case SAVE_NEW_RIFF_SUCCESS:\n      if (action.payload.type === 'add') {\n        let riffs = [...state.all];\n        riffs.forEach((el, ind, arr) => {\n          if (el.tempId === action.payload.tempId)\n            arr[ind] = { ...el, id: action.payload.id };\n          //el.id = action.payload.id;\n        });\n        let ret = { ...state, all: riffs };\n        return ret;\n      }\n      else\n      {\n\n      }\n      //return state;\n\n    /*\n    case LOAD_RIFF:\n      let ret = { ...state }; // will this work?\n      ret.all[action.payload].loading = true;\n      return ret;\n    case RIFF_LOADED: {\n      debugger;\n      const b = new Blob(new Array(action.payload), { type: 'audio/mp3' });\n      let riffs = [...state.all];\n      riffs.forEach(el => {\n        if (el.id === action.id) {\n          el.payload = b;\n          el.loading = false;\n        }\n      });\n      let ret = { ...state, all: riffs };\n\n      // if this is being edited currently, tempRiff needs to be updated as well\n      // editIndex != null simply means that something is being edited\n      if (state.editIndex !== null && state.temp.id === action.id)\n        ret.temp = { ...ret.temp, payload: b };\n\n      return ret;\n    }\n    */\n\n    default:\n      return state;\n  }\n};\n\nexport default riffsReducer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}