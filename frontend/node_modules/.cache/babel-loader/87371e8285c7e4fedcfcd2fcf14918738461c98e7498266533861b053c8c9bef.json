{"ast":null,"code":"var _jsxFileName = \"/Users/davidnewberry/Documents/test_rails/frontend/src/components/YouTubeVideo/YouTubeVideo.js\";\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport { setPlayerMode, setRiffPlaying, loadRiff, togglePlayerMode, setVideoDuration, EDIT_MODE, EDIT_NEW_MODE, PLAY_MODE, PAUSE_MODE } from '../../actions/index.js';\nimport AllowPlayback from './AllowPlayback.js';\n\n// based on https://stackoverflow.com/questions/54017100/how-to-integrate-youtube-iframe-api-in-reactjs-solution\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nclass YouTubeVideo extends React.Component {\n  constructor() {\n    super(...arguments);\n    this.componentDidMount = () => {\n      // On mount, check to see if the API script is already loaded\n\n      if (!window.YT || !window.YT.Player) {\n        // If not, load the script asynchronously\n        const tag = document.createElement('script');\n        tag.src = 'https://www.youtube.com/iframe_api';\n\n        // onYouTubeIframeAPIReady will load the video after the script is loaded\n        window.onYouTubeIframeAPIReady = this.loadVideo;\n        const firstScriptTag = document.getElementsByTagName('script')[0];\n        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\n      } // If script is already there, load the video directly\n      else {\n        this.loadVideo();\n        this.checkForRiffsToLoad(0); // check if any riffs at < 10s in need loading\n      }\n    };\n    this.loadVideo = () => {\n      if (!window.YT) return; // can be called by componentDidUpdate before window.YT has loaded\n\n      const {\n        id\n      } = this.props;\n      if (window.rifftubePlayer) window.rifftubePlayer.destroy();\n      this.player = new window.YT.Player('rifftube-player', {\n        videoId: id,\n        height: \"100%\",\n        width: \"100%\",\n        playerVars: {\n          playsinline: 1 // allows it to play inline on iOS\n        },\n\n        events: {\n          onReady: this.onPlayerReady,\n          onStateChange: this.onPlayerStateChange\n        }\n      });\n      window.rifftubePlayer = this.player; // store global reference (used to get current playback time when needed)\n    };\n    this.onPlayerReady = event => {\n      //event.target.playVideo();\n\n      this.props.setVideoDuration(event.target.getDuration());\n    };\n    this.checkForRiffsToLoad = t => {\n      var _this$props$riffs;\n      (_this$props$riffs = this.props.riffs) === null || _this$props$riffs === void 0 ? void 0 : _this$props$riffs.forEach(riff => {\n        if (\n        // if no id, it's being saved\n        riff.id &&\n        //if it's an audio riff\n        riff.type === 'audio' &&\n        //if it's not loaded already\n        !this.props.riffsAudio[riff.id] &&\n        //!riff.payload &&\n        //if it's not loading\n        !this.props.riffsAudio.loading[riff.id] &&\n        //!riff.loading &&\n        // if the riff is in the future\n        riff.start >= t &&\n        // but is less than 10 seconds in the future\n        riff.start < t + 10)\n          // load the riff to be played at the right time\n          this.props.loadRiff(riff.id);\n      });\n    };\n    this.onPlayerStateChange = _ref => {\n      let {\n        data\n      } = _ref;\n      /*\n          -1 (unstarted)\n          0 (ended)\n          1 (playing)\n          2 (paused)\n          3 (buffering)\n          5 (video cued).\n          */\n\n      // the following conditional leaves out some 'else's that should never occur\n\n      if (data === 1) {\n        // playing\n\n        // the following code is\n        // needed I think... for pausing during a riff.\n        // so that (subsiquent) 'zombie' riffs can be killed,\n        // I think.\n        this.curRiff = this.props.riffsPlaying;\n\n        /*******************************************************/\n        // this timer is responsible for showing and hiding riffs\n        this.riffInterval = setInterval(() => {\n          if (!(window.rifftubePlayer && typeof window.rifftubePlayer.getCurrentTime == 'function')) return;\n          let t = window.rifftubePlayer.getCurrentTime();\n\n          // if the MetaBar component exists, update its playhead\n          if (window.metaPlayHead && window.metaPlayHead.current) {\n            window.metaPlayHead.current.style.left = `${t / this.props.duration * 100}%`;\n            if (window.metaUpdate) window.metaUpdate(window.metaPlayHead.current);\n          }\n\n          //\n          this.checkForRiffsToLoad(t);\n\n          // first stop any zombie riffs\n          this.props.riffs.forEach((riff, index) => {\n            if (this.curRiff[index] && (t < riff.start || t > riff.start + riff.duration)) {\n              if (this.curRiff[index].inUse) this.curRiff[index].inUse = false;\n\n              // by setting this to false, text riffs will be hidden\n              this.props.setRiffPlaying(index, false);\n              this.curRiff[index] = null;\n              if (riff.type === 'audio')\n                // make sure all audio clips have stopped\n                this.audLock--;\n              if (!this.audLock) {\n                window.rifftubePlayer.setVolume(this.vol ? this.vol : 100); // hopefully unnecessary volume failsafe\n                delete this.vol;\n              }\n            }\n          });\n\n          // next start any that should be playing\n          this.props.riffs.forEach((riff, index) => {\n            // the riff will start playing within half a second, or will be skipped\n            if (!this.curRiff[index] && t > riff.start && t < riff.start + 0.5) {\n              this.props.setRiffPlaying(index, true);\n              this.curRiff[index] = true; // used for text only; overwritten for audio\n\n              if (riff.type === 'audio') {\n                if (!this.vol) {\n                  this.vol = window.rifftubePlayer.getVolume();\n                  window.rifftubePlayer.setVolume(this.vol * 0.25);\n                }\n\n                // keeps track of how many audio tracks need to end before volume should be restored\n                if (!this.audLock) this.audLock = 1;else this.audLock++;\n                if (!this.props.riffsAudio[riff.id]) {\n                  //(!riff.payload) {\n                  return;\n                } // DEBUG - SHOULD BE REMOVED\n                var audioURL = URL.createObjectURL(this.props.riffsAudio[riff.id]); //(riff.payload);\n                //debugger;\n\n                window.lastRiff = this.props.riffsAudio[riff.id]; // riff.payload;\n\n                // FIX THIS:\n\n                for (let i = 0; i < window.audioPlayersCount; i++) {\n                  /*\n                  if ( window.audioContexts[i].inUse ) continue;\n                  let audioContext = window.audioContexts[i];\n                  window.audioContexts[i].inUse = true;\n                  var blob = riff.payload;\n                  new Response(blob).arrayBuffer().then(function(arrayBuffer) {\n                    window.audioContexts[0].decodeAudioData(arrayBuffer, audioData => {\n                      debugger;\n                      var source = window.audioContexts[i].createBufferSource();\n                      source.buffer = audioData;\n                      source.connect(window.audioContexts[i].destination);\n                      source.start()\n                    })\n                  });\n                  */\n\n                  let audio = window.audioPlayers[i];\n                  if (audio.inUse) continue;\n                  audio.inUse = true;\n\n                  // TEST:\n                  audio.srcEl.src = audioURL;\n                  audio.load();\n                  audio.play();\n\n                  /*\n                  var se = document.createElement('source');\n                  audio.appendChild(se);\n                  se.src = audioURL;\n                  //se.type = 'audio/webm';\n                  audio.load();\n                  audio.play();\n                  */\n\n                  // ORIG:\n                  /*\n                  audio.src = audioURL;\n                  audio.play();\n                  */\n\n                  this.curRiff[index] = audio; // audioContext;\n                  break;\n                }\n              }\n            }\n          });\n        }, 100); // 100/1000 = 1/10 s\n\n        if (this.props.mode !== PLAY_MODE) {\n          // change mode state\n          this.props.setPlayerMode(PLAY_MODE);\n        }\n      } // not playing\n      else {\n        // stop riff-check interval when not playing\n        clearInterval(this.riffInterval);\n        if (this.props.mode === PLAY_MODE) {\n          // change mode state\n          this.props.setPlayerMode(PAUSE_MODE);\n        }\n      }\n    };\n    this.componentDidUpdate = prevProps => {\n      // seems needed on more than just mounting\n      // (makes sense; the riff meta takes some start to load)\n      this.checkForRiffsToLoad(0); // check if any riffs at < 10s in need loading\n\n      if (this.props.id !== prevProps.id) this.loadVideo();\n      if (!(this.player && this.player.getPlayerState)) return;\n      if (this.props.mode !== prevProps.mode) {\n        if ((this.props.mode === EDIT_MODE || this.props.mode === EDIT_NEW_MODE || this.props.mode === PAUSE_MODE) && this.player.getPlayerState() === 1) {\n          this.player.pauseVideo();\n        } else if (this.props.mode === PLAY_MODE && this.player.getPlayerState() !== 1) {\n          this.player.playVideo();\n        }\n      }\n    };\n    this.render = () => {\n      return /*#__PURE__*/_jsxDEV(React.Fragment, {\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"rifftube-container\",\n          children: [/*#__PURE__*/_jsxDEV(AllowPlayback, {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 282,\n            columnNumber: 11\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"rifftube-overlay\",\n            children: /*#__PURE__*/_jsxDEV(\"div\", {\n              className: \"rifftube-riffs-container\",\n              children: Object.keys(this.props.riffsPlaying).filter(i => this.props.riffsPlaying[i] && this.props.riffs[i] && this.props.riffs[i].type === 'text').map(key => /*#__PURE__*/_jsxDEV(\"div\", {\n                className: \"rifftube-textriff\",\n                children: this.props.riffs[key].payload\n              }, this.props.riffs[key].id, false, {\n                fileName: _jsxFileName,\n                lineNumber: 293,\n                columnNumber: 19\n              }, this))\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 284,\n              columnNumber: 13\n            }, this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 283,\n            columnNumber: 11\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            id: \"rifftube-player\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 302,\n            columnNumber: 11\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 281,\n          columnNumber: 9\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 280,\n        columnNumber: 7\n      }, this);\n    };\n  }\n}\nconst mapStateToProps = state => ({\n  mode: state.mode,\n  riffs: state.riffs,\n  riffsPlaying: state.riffsPlaying,\n  duration: state.duration,\n  riffsAudio: state.riffsAudio\n});\nconst mapDispatchToProps = {\n  setPlayerMode,\n  setRiffPlaying,\n  togglePlayerMode,\n  loadRiff,\n  setVideoDuration\n};\nexport default connect(mapStateToProps, mapDispatchToProps)(YouTubeVideo);","map":{"version":3,"names":["React","connect","setPlayerMode","setRiffPlaying","loadRiff","togglePlayerMode","setVideoDuration","EDIT_MODE","EDIT_NEW_MODE","PLAY_MODE","PAUSE_MODE","AllowPlayback","YouTubeVideo","Component","componentDidMount","window","YT","Player","tag","document","createElement","src","onYouTubeIframeAPIReady","loadVideo","firstScriptTag","getElementsByTagName","parentNode","insertBefore","checkForRiffsToLoad","id","props","rifftubePlayer","destroy","player","videoId","height","width","playerVars","playsinline","events","onReady","onPlayerReady","onStateChange","onPlayerStateChange","event","target","getDuration","t","riffs","forEach","riff","type","riffsAudio","loading","start","data","curRiff","riffsPlaying","riffInterval","setInterval","getCurrentTime","metaPlayHead","current","style","left","duration","metaUpdate","index","inUse","audLock","setVolume","vol","getVolume","audioURL","URL","createObjectURL","lastRiff","i","audioPlayersCount","audio","audioPlayers","srcEl","load","play","mode","clearInterval","componentDidUpdate","prevProps","getPlayerState","pauseVideo","playVideo","render","Object","keys","filter","map","key","payload","mapStateToProps","state","mapDispatchToProps"],"sources":["/Users/davidnewberry/Documents/test_rails/frontend/src/components/YouTubeVideo/YouTubeVideo.js"],"sourcesContent":["import React from 'react';\nimport { connect } from 'react-redux';\nimport {\n  setPlayerMode,\n  setRiffPlaying,\n  loadRiff,\n  togglePlayerMode,\n  setVideoDuration,\n  EDIT_MODE,\n  EDIT_NEW_MODE,\n  PLAY_MODE,\n  PAUSE_MODE,\n} from '../../actions/index.js';\nimport AllowPlayback from './AllowPlayback.js';\n\n// based on https://stackoverflow.com/questions/54017100/how-to-integrate-youtube-iframe-api-in-reactjs-solution\n\nclass YouTubeVideo extends React.Component {\n  componentDidMount = () => {\n    // On mount, check to see if the API script is already loaded\n\n    if (!window.YT || !window.YT.Player) {\n      // If not, load the script asynchronously\n      const tag = document.createElement('script');\n      tag.src = 'https://www.youtube.com/iframe_api';\n\n      // onYouTubeIframeAPIReady will load the video after the script is loaded\n      window.onYouTubeIframeAPIReady = this.loadVideo;\n\n      const firstScriptTag = document.getElementsByTagName('script')[0];\n      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\n    } // If script is already there, load the video directly\n    else {\n      this.loadVideo();\n      this.checkForRiffsToLoad(0); // check if any riffs at < 10s in need loading\n    }\n  };\n\n  loadVideo = () => {\n    if (!window.YT) return; // can be called by componentDidUpdate before window.YT has loaded\n\n    const { id } = this.props;\n\n    if (window.rifftubePlayer) window.rifftubePlayer.destroy();\n\n    this.player = new window.YT.Player('rifftube-player', {\n      videoId: id,\n      height: \"100%\",\n      width: \"100%\",\n      playerVars: {\n        playsinline: 1, // allows it to play inline on iOS\n      },\n      events: {\n        onReady: this.onPlayerReady,\n        onStateChange: this.onPlayerStateChange,\n      },\n    });\n\n    window.rifftubePlayer = this.player; // store global reference (used to get current playback time when needed)\n  };\n\n  onPlayerReady = (event) => {\n    //event.target.playVideo();\n\n    this.props.setVideoDuration(event.target.getDuration());\n  };\n\n  // TODO: account for muted riffs!!!!\n  checkForRiffsToLoad = (t) => {\n    this.props.riffs?.forEach((riff) => {\n      if (\n        // if no id, it's being saved\n        riff.id &&\n        //if it's an audio riff\n        riff.type === 'audio' &&\n        //if it's not loaded already\n        !this.props.riffsAudio[riff.id] && //!riff.payload &&\n        //if it's not loading\n        !this.props.riffsAudio.loading[riff.id] && //!riff.loading &&\n        // if the riff is in the future\n        riff.start >= t &&\n        // but is less than 10 seconds in the future\n        riff.start < t + 10\n      )\n        // load the riff to be played at the right time\n        this.props.loadRiff(riff.id);\n    });\n  };\n\n  onPlayerStateChange = ({ data }) => {\n    /*\n        -1 (unstarted)\n        0 (ended)\n        1 (playing)\n        2 (paused)\n        3 (buffering)\n        5 (video cued).\n        */\n\n    // the following conditional leaves out some 'else's that should never occur\n\n    if (data === 1) {\n      // playing\n\n      // the following code is\n      // needed I think... for pausing during a riff.\n      // so that (subsiquent) 'zombie' riffs can be killed,\n      // I think.\n      this.curRiff = this.props.riffsPlaying;\n\n      /*******************************************************/\n      // this timer is responsible for showing and hiding riffs\n      this.riffInterval = setInterval(() => {\n        if (\n          !(\n            window.rifftubePlayer &&\n            typeof window.rifftubePlayer.getCurrentTime == 'function'\n          )\n        )\n          return;\n\n        let t = window.rifftubePlayer.getCurrentTime();\n\n        // if the MetaBar component exists, update its playhead\n        if (window.metaPlayHead && window.metaPlayHead.current) {\n          window.metaPlayHead.current.style.left = `${\n            (t / this.props.duration) * 100\n          }%`;\n          if (window.metaUpdate) window.metaUpdate(window.metaPlayHead.current);\n        }\n\n        //\n        this.checkForRiffsToLoad(t);\n\n        // first stop any zombie riffs\n        this.props.riffs.forEach((riff, index) => {\n          if (\n            this.curRiff[index] &&\n            (t < riff.start || t > riff.start + riff.duration)\n          ) {\n            if (this.curRiff[index].inUse) this.curRiff[index].inUse = false;\n\n            // by setting this to false, text riffs will be hidden\n            this.props.setRiffPlaying(index, false);\n            this.curRiff[index] = null;\n\n            if (riff.type === 'audio')\n              // make sure all audio clips have stopped\n              this.audLock--;\n            if (!this.audLock) {\n              window.rifftubePlayer.setVolume(this.vol ? this.vol : 100); // hopefully unnecessary volume failsafe\n              delete this.vol;\n            }\n          }\n        });\n\n        // next start any that should be playing\n        this.props.riffs.forEach((riff, index) => {\n          // the riff will start playing within half a second, or will be skipped\n          if (!this.curRiff[index] && t > riff.start && t < riff.start + 0.5) {\n            this.props.setRiffPlaying(index, true);\n            this.curRiff[index] = true; // used for text only; overwritten for audio\n\n            if (riff.type === 'audio') {\n              if (!this.vol) {\n                this.vol = window.rifftubePlayer.getVolume();\n                window.rifftubePlayer.setVolume(this.vol * 0.25);\n              }\n\n              // keeps track of how many audio tracks need to end before volume should be restored\n              if (!this.audLock) this.audLock = 1;\n              else this.audLock++;\n\n              if (!this.props.riffsAudio[riff.id]) {\n                //(!riff.payload) {\n                return;\n              } // DEBUG - SHOULD BE REMOVED\n              var audioURL = URL.createObjectURL(\n                this.props.riffsAudio[riff.id]\n              ); //(riff.payload);\n              //debugger;\n\n              window.lastRiff = this.props.riffsAudio[riff.id]; // riff.payload;\n\n              // FIX THIS:\n\n              for (let i = 0; i < window.audioPlayersCount; i++) {\n                /*\n                if ( window.audioContexts[i].inUse ) continue;\n                let audioContext = window.audioContexts[i];\n                window.audioContexts[i].inUse = true;\n                var blob = riff.payload;\n                new Response(blob).arrayBuffer().then(function(arrayBuffer) {\n                  window.audioContexts[0].decodeAudioData(arrayBuffer, audioData => {\n                    debugger;\n                    var source = window.audioContexts[i].createBufferSource();\n                    source.buffer = audioData;\n                    source.connect(window.audioContexts[i].destination);\n                    source.start()\n                  })\n                });\n                */\n\n                let audio = window.audioPlayers[i];\n                if (audio.inUse) continue;\n                audio.inUse = true;\n\n                // TEST:\n                audio.srcEl.src = audioURL;\n                audio.load();\n                audio.play();\n\n                /*\n                var se = document.createElement('source');\n                audio.appendChild(se);\n                se.src = audioURL;\n                //se.type = 'audio/webm';\n                audio.load();\n                audio.play();\n                */\n\n                // ORIG:\n                /*\n                audio.src = audioURL;\n                audio.play();\n                */\n\n                this.curRiff[index] = audio; // audioContext;\n                break;\n              }\n            }\n          }\n        });\n      }, 100); // 100/1000 = 1/10 s\n\n      if (this.props.mode !== PLAY_MODE) {\n        // change mode state\n        this.props.setPlayerMode(PLAY_MODE);\n      }\n    } // not playing\n    else {\n      // stop riff-check interval when not playing\n      clearInterval(this.riffInterval);\n\n      if (this.props.mode === PLAY_MODE) {\n        // change mode state\n        this.props.setPlayerMode(PAUSE_MODE);\n      }\n    }\n  };\n\n  componentDidUpdate = (prevProps) => {\n    // seems needed on more than just mounting\n    // (makes sense; the riff meta takes some start to load)\n    this.checkForRiffsToLoad(0); // check if any riffs at < 10s in need loading\n\n    if (this.props.id !== prevProps.id) this.loadVideo();\n\n    if (!(this.player && this.player.getPlayerState)) return;\n\n    if (this.props.mode !== prevProps.mode) {\n      if (\n        (this.props.mode === EDIT_MODE ||\n          this.props.mode === EDIT_NEW_MODE ||\n          this.props.mode === PAUSE_MODE) &&\n        this.player.getPlayerState() === 1\n      ) {\n        this.player.pauseVideo();\n      } else if (\n        this.props.mode === PLAY_MODE &&\n        this.player.getPlayerState() !== 1\n      ) {\n        this.player.playVideo();\n      }\n    }\n  };\n\n  render = () => {\n    return (\n      <React.Fragment>\n        <div className=\"rifftube-container\">\n          <AllowPlayback />\n          <div className=\"rifftube-overlay\">\n            <div className=\"rifftube-riffs-container\">\n              {Object.keys(this.props.riffsPlaying)\n                .filter(\n                  (i) =>\n                    this.props.riffsPlaying[i] &&\n                    this.props.riffs[i] &&\n                    this.props.riffs[i].type === 'text'\n                )\n                .map((key) => (\n                  <div\n                    key={this.props.riffs[key].id}\n                    className=\"rifftube-textriff\"\n                  >\n                    {this.props.riffs[key].payload}\n                  </div>\n                ))}\n            </div>\n          </div>\n          <div id=\"rifftube-player\" />\n        </div>\n      </React.Fragment>\n    );\n  };\n}\n\nconst mapStateToProps = (state) => ({\n  mode: state.mode,\n  riffs: state.riffs,\n  riffsPlaying: state.riffsPlaying,\n  duration: state.duration,\n  riffsAudio: state.riffsAudio,\n});\n\nconst mapDispatchToProps = {\n  setPlayerMode,\n  setRiffPlaying,\n  togglePlayerMode,\n  loadRiff,\n  setVideoDuration,\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(YouTubeVideo);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}