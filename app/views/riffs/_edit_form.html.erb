<div style="margin-top: 1em;">
<audio controls
    src="<%= id.present? ? riff_path(id) : '' %>">
</audio>
</div>

<div>
<button
    class="rifftube-record-btn"
    onMouseDown="rifftube.record_start()"
    onMouseUp="rifftube.record_stop()">
    record
</button>
<button
    class="rifftube-timing-btn"
    onMouseDown="rifftube.timing_start()"
    onMouseUp="rifftube.timing_stop()">
    time
</button>
(press and hold)
</div>

<%= form_with model: @riff, multipart: true do |form| %>

<%= form.hidden_field :id %>

<% if video_id.present? %>
<input type="hidden" name="riff[video_id]" value="<%= video_id %>">
<% end %>

<div>
<%= form.collection_radio_buttons :audio_type,
    [[1, "Recorded audio"], [2, "Synthesized audio"], [3, "No audio"]],
    :first, :last %>
</div>

<div>
<%= form.label :text, "Riff Text" %><br>
<%= form.text_area :text %><br>
</div>

<div>
<%= form.check_box :showText %>
<%= form.label :showText, "Display text" %>
</div>

<div>
<%= form.label :start, "Start Time" %><br>
<%= form.number_field :start, step: 0.5 %><br>
</div>

<details>
    <summary>Advanced Options</summary>
    <div>
        <input type="file" name="riff[audio]" accept="audio/mp4">
    </div>
    <div>
        <%= form.label :duration %>
        <%= form.number_field :duration, step: 0.5 %>
    </div>
    <div>
        <%= form.check_box :autoDuration %>
        <%= form.label :autoDuration, "Auto-determine duration" %>
    </div>
</details>

<div style="margin-top: 1em;">
<button
    onClick="rifftube.close_modal(); event.preventDefault();">
    Cancel
</button>

<button
    onClick="rifftube.save_riff(event);">
    Save
</button>
</div>

</div>

<% end %>

<script>

function duplicate_blob(blob)
{
    return blob.slice(0, blob.size, blob.type);
}


// rifftube-riff-edit-dialog class
// data-riff-id or data-new-riff attribute for edit / new
var dialSel = ".rifftube-riff-edit-dialog[data-<%= id.present? ? "riff-id='#{id}'".html_safe : "new-riff" %>]";
var curDial = document.querySelector(dialSel);
var rifftube = curDial.rifftube || {};

rifftube.curDial = curDial;
rifftube.curRecBtn = rifftube.curDial.querySelector(".rifftube-record-btn");
rifftube.TimBtn = rifftube.curDial.querySelector(".rifftube-timing-btn");
rifftube.curPlayer = rifftube.curDial.querySelector("audio");
rifftube.curForm = rifftube.curDial.querySelector("form");
rifftube.curFile = rifftube.curDial.querySelector("input[type='file']");
rifftube.curDur = rifftube.curForm.querySelector("[name='riff[duration]']");
rifftube.curShowChk = rifftube.curForm.querySelector("[type='checkbox'][name='riff[showText]']");
rifftube.curTextArea = rifftube.curForm.querySelector("textarea");
rifftube.curAutoChk = rifftube.curForm.querySelector("[type='checkbox'][name='riff[autoDuration]']");
rifftube.curTypeRad = rifftube.curForm.querySelectorAll("[type='radio'][name='riff[audio_type]']");
rifftube.curStart = rifftube.curForm.querySelector("[name='riff[start]']");

/*
use audio:          isText  speak
- recorded          false   false
- synthesized       true    true 
- no                true    false
isText = false -> speak = false, auto-duration = true (show = t/f)
isText = true, speak = false -> show = true (auto-duration = t/f)
isText = true, speak = true -> auto-duration = true (show = t/f)
*/

// maybe don't need to duplicate all the time? ... not sure

if (rifftube.curFile.files.length == 1)
{
    let audio_URL = URL.createObjectURL(duplicate_blob(rifftube.curFile.files[0]));
    rifftube.curPlayer.src = audio_URL;
    rifftube.temp_audio = duplicate_blob(rifftube.curFile.files[0])
    console.log("did it", rifftube.curFile.files[0]);
}

/*
//debugger;
if (navigator.mediaDevices)
{
    navigator.mediaDevices
        .getUserMedia({ audio: true, video: false })
        .then((stream) =>
        {
            rifftube.stream = stream;
            
            
        })
        .catch( (err) => {
            //enable the record button if getUSerMedia() fails
            console.log("oops, can't get stream", err);
        });
}
*/

rifftube.timing_start = function()
{
    if (rifftube.recording) return;

    //debugger;

    console.log("start text")

    rifftube.recording = true;

    rifftube.TimBtn.innerHTML = "timing...";

    rifftube.record_start_time = Date.now();
}


rifftube.timing_stop = function()
{
    if (!rifftube.recording) return;

    console.log("end text")

    rifftube.recording = false;

    rifftube.TimBtn.innerHTML = "time";

    rifftube.riff_duration = (Date.now() - rifftube.record_start_time) / 1000;

    rifftube.curDur.value = rifftube.riff_duration;
}

rifftube.record_start = function()
{
    // make sure the recorder has been set up
    if (!rifftube.recorderLoaded) return;

    // ignore keypress (likely key repeat) if recording
    if (rifftube.recording) return;

    //debugger;

    console.log("start rec", rifftube)

    rifftube.recording = true;

    rifftube.curRecBtn.innerHTML = "recording..."

    rifftube.record_start_time = Date.now();

    rifftube.recorder.start();
}


rifftube.record_stop = function()
{
    if (!rifftube.recording) return;

    rifftube.recorder.stop();

    console.log("end rec", rifftube)

    rifftube.recording = false;

    rifftube.curRecBtn.innerHTML = "record"

    rifftube.riff_duration = (Date.now() - rifftube.record_start_time) / 1000;

    //debugger;
    rifftube.curDur.value = rifftube.riff_duration;
}

rifftube.close_modal = function()
{
    /* // no longer needed
    let cust_event = new CustomEvent("rifftube:riff:save:close");
    document.dispatchEvent(cust_event);
    console.log(cust_event);
    */

    /*
    rifftube.curDial.close();
    rifftube.curDial.remove();
    */
}

rifftube.save_riff = function(event)
{
    //debugger;

    event.preventDefault();

   // remove disabled attribute to send all fields
   rifftube.curForm.querySelectorAll("[disabled]")
        .forEach(el => el.removeAttribute("disabled"))

    let detail = new FormData(rifftube.curForm);

    let cust_event = new CustomEvent("rifftube:riff:save", { detail });
    document.dispatchEvent(cust_event);
    console.log(cust_event);

    rifftube.close_modal();
}

console.log("injected script running");

//debugger;

rifftube.rec_keydown = function(e)
{
    console.log("rec kd", rifftube.curTypeRad[2].checked);
    if ( event.getModifierState("Control") +
            event.getModifierState("Alt") +
            event.getModifierState("Meta") > 1 )
        return;

    if (e.key == 'r')
    {
        rifftube.record_start();
    }
    else if (e.key == 't' && rifftube.curTypeRad[2].checked)
    {
        rifftube.timing_start();
    }

    e.stopPropagation();
}

rifftube.rec_keyup = function(e)
{
    if ( event.getModifierState("Control") +
            event.getModifierState("Alt") +
            event.getModifierState("Meta") > 1 )
        return;

    if (e.key == 'r')
    {
        rifftube.record_stop();
    }
    else if (e.key == 't' && rifftube.curTypeRad[2].checked)
    {
        rifftube.timing_stop();
    }
}

rifftube.audioTypeUICallback = function(e)
{
    if ( e.target == rifftube.curTypeRad[0] )
    {
        rifftube.curAutoChk.checked = true;
        rifftube.curAutoChk.disabled = true;
        rifftube.curDur.disabled = true;
        rifftube.TimBtn.disabled = true;
        rifftube.curShowChk.disabled = false;
    }
    else if ( e.target == rifftube.curTypeRad[1] )
    {
        rifftube.curAutoChk.checked = true;
        rifftube.curAutoChk.disabled = true;
        rifftube.curDur.disabled = true;
        rifftube.TimBtn.disabled = true;
        rifftube.curShowChk.disabled = false;
    }
    else if ( e.target == rifftube.curTypeRad[2] )
    {
        rifftube.curShowChk.checked = true;
        rifftube.curShowChk.disabled = true;
        rifftube.curAutoChk.disabled = false;
        rifftube.curDur.disabled = false;
        rifftube.TimBtn.disabled = false;

    }
};

rifftube.audioAutoDurUICallback = function(e)
{
    rifftube.curDur.disabled = e.target.checked;
    if (e.target.checked)
    {
        rifftube.cachedDur = rifftube.curDur.value;
        rifftube.curDur.value = "";
    }
    else
        rifftube.curDur.value = rifftube.cachedDur;
};

rifftube.setupStartCallback = function(e)
{
    console.log(e);

    rifftube.curStart.value = e.detail.start.toFixed(2);
}

rifftube.setupRecorderCallback = function(e)
{
    console.log(e);

    rifftube.recorder = e.detail.recorder; // new MediaRecorder(stream);

    rifftube.chunks = [];
    rifftube.recorder.ondataavailable = function(e)
    {
        rifftube.chunks.push(e.data);
    }

    rifftube.recorder.onstop = function(e)
    {
        console.log("recorder stopped, saving ", rifftube.recorder);

        rifftube.temp_audio = new Blob(rifftube.chunks, { 'type' : rifftube.recorder.mimeType });
        
        rifftube.chunks = [];
        
        rifftube.audio_URL = URL.createObjectURL(duplicate_blob(rifftube.temp_audio));

        rifftube.curPlayer.src = rifftube.audio_URL;

        // Wrap audio blob as File; use DataTransfer to create a files object; assign to file input.
        // This keeps the audio in place in case of navigation away and back.
        // Other code reads it from the input and restores the audio player's src attr.
        let file = new File([rifftube.temp_audio], `Recorded audio ${new Date().toLocaleTimeString()}`, {type: rifftube.recorder.mimeType, lastModified: Date.now()});
        let container = new DataTransfer();
        container.items.add(file);
        rifftube.curFile.files = container.files;
    }

    console.log("checking for immediate record")

    //debugger;

    // immediate start
    rifftube.recorderLoaded = true;
    if (rifftube.curDial.hasAttribute("data-immediate-record"))
        rifftube.record_start();
}

rifftube.curTypeRad.forEach( el => el.addEventListener("change", rifftube.audioTypeUICallback) );
rifftube.curAutoChk.addEventListener("change", rifftube.audioAutoDurUICallback);

rifftube.curDial.addEventListener('keydown', rifftube.rec_keydown, false);
rifftube.curDial.addEventListener('keyup', rifftube.rec_keyup, false);

rifftube.curTextArea.addEventListener('keydown', e => e.stopPropagation(), false);

rifftube.curDial.addEventListener("cancel", () => { rifftube.close_modal(); }, false);

//console.log("adding listener", rifftube.curDial);
rifftube.curDial.addEventListener("rifftube:riff:edit:setup:recorder", rifftube.setupRecorderCallback, false);
rifftube.curDial.addEventListener("rifftube:riff:edit:setup:start", rifftube.setupStartCallback, false);

if (rifftube.curDial.hasAttribute("data-immediate-record"))
{
    rifftube.curTypeRad[0].checked = true;
    rifftube.audioTypeUICallback({ target: rifftube.curTypeRad[0] });
}
else if (rifftube.curDial.hasAttribute("data-immediate-text"))
{
    rifftube.curTypeRad[2].checked = true;
    rifftube.audioTypeUICallback({ target: rifftube.curTypeRad[2] });
    rifftube.timing_start();
}
else
{
    rifftube.curTypeSel = rifftube.curForm.querySelector("[type='radio'][name='riff[audio_type]'][checked]");
    rifftube.audioTypeUICallback({ target: rifftube.curTypeSel });
}

console.log("edit form loaded");

//rifftube.curDial.showModal();

</script>